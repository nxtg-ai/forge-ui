#!/usr/bin/env python3
"""NXTG-Forge Initialization Command

Copies .claude/ directory structure from package to target project.
This is what makes NXTG-Forge truly "drop-in ready".
"""

import shutil
import sys
from pathlib import Path
from typing import Optional

from rich.console import Console
from rich.panel import Panel
from rich.syntax import Syntax
from rich.tree import Tree

console = Console()


class ForgeInitializer:
    """Handles initialization of NXTG-Forge in existing projects"""

    def __init__(self, target_dir: Optional[Path] = None):
        """Initialize the ForgeInitializer

        Args:
            target_dir: Target project directory (defaults to current directory)
        """
        self.target_dir = target_dir or Path.cwd()
        self.target_claude = self.target_dir / ".claude"

        # Find package installation location
        import forge
        self.package_dir = Path(forge.__file__).parent.parent
        self.source_claude = self.package_dir / ".claude"

    def check_existing(self) -> bool:
        """Check if .claude/ already exists in target directory

        Returns:
            True if .claude/ exists, False otherwise
        """
        return self.target_claude.exists()

    def get_source_stats(self) -> dict:
        """Get statistics about source .claude/ directory

        Returns:
            Dictionary with file counts by type
        """
        if not self.source_claude.exists():
            return {}

        stats = {
            "commands": 0,
            "skills": 0,
            "hooks": 0,
            "prompts": 0,
            "workflows": 0,
            "total": 0,
        }

        for item in self.source_claude.rglob("*"):
            if item.is_file():
                stats["total"] += 1
                if "commands" in str(item):
                    stats["commands"] += 1
                elif "skills" in str(item):
                    stats["skills"] += 1
                elif "hooks" in str(item):
                    stats["hooks"] += 1
                elif "prompts" in str(item):
                    stats["prompts"] += 1
                elif "workflows" in str(item):
                    stats["workflows"] += 1

        return stats

    def copy_claude_directory(self, force: bool = False) -> bool:
        """Copy .claude/ directory from package to target

        Args:
            force: If True, overwrite existing files

        Returns:
            True if successful, False otherwise
        """
        # Check if source exists
        if not self.source_claude.exists():
            console.print(
                "[red]ERROR: Could not find .claude/ in package installation[/red]"
            )
            console.print(
                f"[yellow]Expected location: {self.source_claude}[/yellow]"
            )
            console.print(
                "\n[yellow]This is a packaging issue. The .claude/ directory should be included.[/yellow]"
            )
            return False

        # Check if target exists
        if self.target_claude.exists() and not force:
            console.print(
                f"[yellow]WARNING: .claude/ already exists in {self.target_dir}[/yellow]"
            )
            console.print(
                "\n[cyan]Use --force to overwrite existing files[/cyan]"
            )
            return False

        try:
            # Copy directory structure
            console.print(f"\n[cyan]Copying .claude/ to {self.target_dir}...[/cyan]")
            console.print(f"[dim]Source: {self.source_claude}[/dim]")
            console.print(f"[dim]Destination: {self.target_claude}[/dim]")

            if self.target_claude.exists() and force:
                console.print("[yellow]Removing existing .claude/ directory...[/yellow]")
                shutil.rmtree(self.target_claude)

            shutil.copytree(
                self.source_claude,
                self.target_claude,
                dirs_exist_ok=True,
            )

            # Verify copy
            import os
            file_count = sum([len(files) for r, d, files in os.walk(self.target_claude)])
            console.print(f"[green]Successfully copied {file_count} files[/green]")

            return True

        except Exception as e:
            console.print(f"[red]ERROR: Failed to copy .claude/ directory: {e}[/red]")
            return False

    def create_forge_config(self) -> bool:
        """Create initial forge configuration

        Returns:
            True if successful, False otherwise
        """
        forge_dir = self.target_claude / "forge"
        config_file = forge_dir / "config.yml"

        try:
            forge_dir.mkdir(parents=True, exist_ok=True)

            # Only create config if it doesn't exist
            if not config_file.exists():
                config_content = f"""# NXTG-Forge Configuration
# Generated by: forge init

project:
  name: {self.target_dir.name}
  root: {self.target_dir}

agents:
  enabled: true
  auto_assign: true

quality:
  min_test_coverage: 80
  enable_pre_commit: true

checkpoints:
  auto_create: true
  on_feature_complete: true

analytics:
  enabled: true
  track_velocity: true
"""
                config_file.write_text(config_content)

            return True

        except Exception as e:
            console.print(f"[red]ERROR: Failed to create config: {e}[/red]")
            return False

    def show_success_message(self, stats: dict):
        """Display success message with next steps

        Args:
            stats: Statistics about copied files
        """
        # Create file tree
        tree = Tree(
            f"[bold cyan].claude/[/bold cyan]",
            guide_style="bright_black",
        )

        if stats.get("commands", 0) > 0:
            tree.add(f"[green]commands/[/green] ({stats['commands']} slash commands)")
        if stats.get("skills", 0) > 0:
            tree.add(f"[blue]skills/[/blue] ({stats['skills']} agent capabilities)")
        if stats.get("hooks", 0) > 0:
            tree.add(f"[yellow]hooks/[/yellow] ({stats['hooks']} lifecycle hooks)")
        if stats.get("prompts", 0) > 0:
            tree.add(f"[magenta]prompts/[/magenta] ({stats['prompts']} templates)")
        if stats.get("workflows", 0) > 0:
            tree.add(f"[cyan]workflows/[/cyan] ({stats['workflows']} automation scripts)")
        tree.add("[green]forge/[/green] (configuration)")

        console.print()
        console.print(Panel(
            tree,
            title="[bold green]NXTG-Forge Initialized Successfully[/bold green]",
            border_style="green",
        ))

        # Next steps
        next_steps = """[bold cyan]Next Steps:[/bold cyan]

1. [green]cd[/green] [yellow]{}[/yellow]
2. [green]claude[/green]
3. Type: [yellow]/status[/yellow]

[bold cyan]Available Commands:[/bold cyan]
  [yellow]/init[/yellow]      - Initialize or upgrade NXTG-Forge
  [yellow]/feature[/yellow]   - Add new feature with full agent orchestration
  [yellow]/status[/yellow]    - Display complete project state
  [yellow]/checkpoint[/yellow] - Create state checkpoint
  [yellow]/gap-analysis[/yellow] - Analyze improvement opportunities

[dim]That's it. It actually works now.[/dim]
""".format(self.target_dir)

        console.print(Panel(
            next_steps,
            border_style="cyan",
            padding=(1, 2),
        ))

    def run(self, force: bool = False, quiet: bool = False) -> bool:
        """Run the initialization process

        Args:
            force: Overwrite existing files
            quiet: Suppress output except errors

        Returns:
            True if successful, False otherwise
        """
        if not quiet:
            console.print()
            console.print(Panel(
                f"[bold]Initializing NXTG-Forge in:[/bold]\n{self.target_dir}",
                border_style="cyan",
            ))

        # Get source stats
        stats = self.get_source_stats()

        if not stats:
            console.print(
                "[red]ERROR: .claude/ directory not found in package installation[/red]"
            )
            console.print(
                f"[yellow]Package location: {self.package_dir}[/yellow]"
            )
            console.print(
                "\n[yellow]This is a packaging issue. Please report this bug.[/yellow]"
            )
            return False

        # Copy .claude/ directory
        if not self.copy_claude_directory(force=force):
            return False

        if not quiet:
            console.print("[green]Copied .claude/ directory structure[/green]")

        # Create forge config
        if not self.create_forge_config():
            return False

        if not quiet:
            console.print("[green]Created forge configuration[/green]")

        # Show success
        if not quiet:
            self.show_success_message(stats)

        return True


def init_project(
    target_dir: Optional[Path] = None,
    force: bool = False,
    quiet: bool = False,
) -> int:
    """Initialize NXTG-Forge in a project directory

    Args:
        target_dir: Target project directory (defaults to current directory)
        force: Overwrite existing files
        quiet: Suppress output except errors

    Returns:
        Exit code (0 for success, 1 for failure)
    """
    initializer = ForgeInitializer(target_dir)
    success = initializer.run(force=force, quiet=quiet)
    return 0 if success else 1


def main():
    """Entry point for forge-init script"""
    import argparse

    parser = argparse.ArgumentParser(
        description="Initialize NXTG-Forge in existing project"
    )
    parser.add_argument(
        "directory",
        nargs="?",
        type=Path,
        help="Target directory (default: current directory)",
    )
    parser.add_argument(
        "--force",
        action="store_true",
        help="Overwrite existing .claude/ directory",
    )
    parser.add_argument(
        "--quiet",
        action="store_true",
        help="Suppress output except errors",
    )

    args = parser.parse_args()

    exit_code = init_project(
        target_dir=args.directory,
        force=args.force,
        quiet=args.quiet,
    )

    sys.exit(exit_code)


if __name__ == "__main__":
    main()
