import{r as e}from"./index-BxVXaorc.js";const W=s=>{const{url:m,reconnectDelay:o=5e3,maxReconnectAttempts:c=5,heartbeatInterval:b=3e4,onOpen:u,onClose:y,onError:a,onReconnect:i}=s,[l,r]=e.useState({status:"disconnected",reconnectAttempt:0,latency:0}),[R,p]=e.useState([]),t=e.useRef(null),E=e.useRef(void 0),d=e.useRef(void 0),g=e.useRef(0),S=e.useRef(u),C=e.useRef(y),v=e.useRef(a),A=e.useRef(i);e.useEffect(()=>{S.current=u},[u]),e.useEffect(()=>{C.current=y},[y]),e.useEffect(()=>{v.current=a},[a]),e.useEffect(()=>{A.current=i},[i]);const w=n=>Math.min(o*Math.pow(2,n),3e4),O=e.useCallback(()=>{d.current&&clearInterval(d.current),d.current=setInterval(()=>{t.current?.readyState===WebSocket.OPEN&&(g.current=Date.now(),t.current.send(JSON.stringify({type:"ping"})))},b)},[b]),h=e.useCallback(()=>{d.current&&clearInterval(d.current)},[]),I=e.useCallback(()=>{if(t.current?.readyState!==WebSocket.OPEN){r(n=>({...n,status:n.reconnectAttempt>0?"reconnecting":"connecting"}));try{t.current=new WebSocket(m),t.current.onopen=()=>{r({status:"connected",lastConnected:new Date,reconnectAttempt:0,latency:0}),O(),S.current?.()},t.current.onmessage=n=>{try{const f=JSON.parse(n.data);if(f.type==="pong"&&g.current){const k=Date.now()-g.current;r(M=>({...M,latency:k}));return}p(k=>[...k,f])}catch(f){console.error("Failed to parse WebSocket message:",f)}},t.current.onerror=n=>{r(f=>({...f,status:"error"})),v.current?.(n)},t.current.onclose=()=>{if(r(n=>({...n,status:"disconnected"})),h(),C.current?.(),l.reconnectAttempt<c){const n=l.reconnectAttempt+1,f=w(n);r(k=>({...k,reconnectAttempt:n})),A.current?.(n),E.current=setTimeout(()=>{I()},f)}}}catch(n){console.error("WebSocket connection failed:",n),r(f=>({...f,status:"error"}))}}},[m,l.reconnectAttempt,c,O,h]),T=e.useCallback(()=>{E.current&&clearTimeout(E.current),h(),t.current&&(t.current.close(),t.current=null),r({status:"disconnected",reconnectAttempt:0,latency:0})},[h]),P=e.useCallback(n=>t.current?.readyState===WebSocket.OPEN?(t.current.send(JSON.stringify(n)),!0):!1,[]),D=e.useCallback(()=>{p([])},[]);return e.useEffect(()=>{const n=setTimeout(()=>{I()},500);return()=>{clearTimeout(n),T()}},[]),{connectionState:l,messages:R,sendMessage:P,clearMessages:D,connect:I,disconnect:T,isConnected:l.status==="connected",isReconnecting:l.status==="reconnecting"}},x=(s,m)=>{const[o,c]=e.useState(s),[b,u]=e.useState(!1),[y,a]=e.useState(null),i=e.useRef(s),l=e.useCallback(async R=>{const p=typeof R=="function"?R(o):R;i.current=o,c(p),u(!0),a(null);try{const t=await m(p);return c(t),t}catch(t){throw c(i.current),a(t),t}finally{u(!1)}},[o,m]),r=e.useCallback(()=>{c(s),a(null)},[s]);return{value:o,update:l,reset:r,isUpdating:b,error:y,rollback:()=>c(i.current)}},J=(s,m={})=>{const{baseInterval:o=1e3,maxInterval:c=3e4,enabled:b=!0,onError:u}=m,[y,a]=e.useState(!1),[i,l]=e.useState(null),[r,R]=e.useState(0),p=e.useRef(void 0),t=e.useRef(o),E=e.useRef(s),d=e.useRef(u);e.useEffect(()=>{E.current=s},[s]),e.useEffect(()=>{d.current=u},[u]);const g=e.useCallback(C=>{C?(t.current=o,R(0)):(t.current=Math.min(t.current*2,c),R(v=>v+1))},[o,c]),S=e.useCallback(async()=>{a(!0);try{await E.current(),l(new Date),g(!0)}catch(C){console.error("Polling error:",C),g(!1),d.current?.(C)}finally{a(!1)}p.current=setTimeout(S,t.current)},[g]);return e.useEffect(()=>(b&&S(),()=>{p.current&&clearTimeout(p.current)}),[b,S]),{isPolling:y,lastFetch:i,errorCount:r,currentInterval:t.current,forceRefresh:S}};export{x as a,J as b,W as u};
//# sourceMappingURL=useRealtimeConnection-lFI03J7E.js.map
