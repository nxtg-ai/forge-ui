{"version":3,"file":"useRealtimeConnection-kGdQG3NU.js","sources":["../../src/hooks/useRealtimeConnection.ts"],"sourcesContent":["import { useState, useEffect, useCallback, useRef } from \"react\";\n\ninterface WebSocketConfig {\n  url: string;\n  reconnectDelay?: number;\n  maxReconnectAttempts?: number;\n  heartbeatInterval?: number;\n  onOpen?: () => void;\n  onClose?: () => void;\n  onError?: (error: Event) => void;\n  onReconnect?: (attempt: number) => void;\n}\n\ninterface ConnectionState {\n  status:\n    | \"connecting\"\n    | \"connected\"\n    | \"disconnected\"\n    | \"reconnecting\"\n    | \"error\";\n  lastConnected?: Date;\n  reconnectAttempt: number;\n  latency: number;\n}\n\nexport const useRealtimeConnection = <T = any>(config: WebSocketConfig) => {\n  const {\n    url,\n    reconnectDelay = 5000,\n    maxReconnectAttempts = 5,\n    heartbeatInterval = 30000,\n    onOpen,\n    onClose,\n    onError,\n    onReconnect,\n  } = config;\n\n  const [connectionState, setConnectionState] = useState<ConnectionState>({\n    status: \"disconnected\",\n    reconnectAttempt: 0,\n    latency: 0,\n  });\n\n  const [messages, setMessages] = useState<T[]>([]);\n  const wsRef = useRef<WebSocket | null>(null);\n  const reconnectTimeoutRef = useRef<NodeJS.Timeout | undefined>(undefined);\n  const heartbeatIntervalRef = useRef<NodeJS.Timeout | undefined>(undefined);\n  const pingTimestampRef = useRef<number>(0);\n\n  // Store callbacks in refs to avoid dependency issues\n  const onOpenRef = useRef(onOpen);\n  const onCloseRef = useRef(onClose);\n  const onErrorRef = useRef(onError);\n  const onReconnectRef = useRef(onReconnect);\n\n  useEffect(() => {\n    onOpenRef.current = onOpen;\n  }, [onOpen]);\n  useEffect(() => {\n    onCloseRef.current = onClose;\n  }, [onClose]);\n  useEffect(() => {\n    onErrorRef.current = onError;\n  }, [onError]);\n  useEffect(() => {\n    onReconnectRef.current = onReconnect;\n  }, [onReconnect]);\n\n  // Exponential backoff for reconnection\n  const getReconnectDelay = (attempt: number) => {\n    return Math.min(reconnectDelay * Math.pow(2, attempt), 30000);\n  };\n\n  // Heartbeat/ping mechanism\n  const startHeartbeat = useCallback(() => {\n    if (heartbeatIntervalRef.current) {\n      clearInterval(heartbeatIntervalRef.current);\n    }\n\n    heartbeatIntervalRef.current = setInterval(() => {\n      if (wsRef.current?.readyState === WebSocket.OPEN) {\n        pingTimestampRef.current = Date.now();\n        wsRef.current.send(JSON.stringify({ type: \"ping\" }));\n      }\n    }, heartbeatInterval);\n  }, [heartbeatInterval]);\n\n  const stopHeartbeat = useCallback(() => {\n    if (heartbeatIntervalRef.current) {\n      clearInterval(heartbeatIntervalRef.current);\n    }\n  }, []);\n\n  // Connect to WebSocket\n  const connect = useCallback(() => {\n    if (wsRef.current?.readyState === WebSocket.OPEN) {\n      return;\n    }\n\n    setConnectionState((prev) => ({\n      ...prev,\n      status: prev.reconnectAttempt > 0 ? \"reconnecting\" : \"connecting\",\n    }));\n\n    try {\n      wsRef.current = new WebSocket(url);\n\n      wsRef.current.onopen = () => {\n        setConnectionState({\n          status: \"connected\",\n          lastConnected: new Date(),\n          reconnectAttempt: 0,\n          latency: 0,\n        });\n        startHeartbeat();\n        onOpenRef.current?.();\n      };\n\n      wsRef.current.onmessage = (event) => {\n        try {\n          const data = JSON.parse(event.data);\n\n          // Handle pong response\n          if (data.type === \"pong\" && pingTimestampRef.current) {\n            const latency = Date.now() - pingTimestampRef.current;\n            setConnectionState((prev) => ({ ...prev, latency }));\n            return;\n          }\n\n          // Add message to queue\n          setMessages((prev) => [...prev, data as T]);\n        } catch (error) {\n          console.error(\"Failed to parse WebSocket message:\", error);\n        }\n      };\n\n      wsRef.current.onerror = (event) => {\n        setConnectionState((prev) => ({\n          ...prev,\n          status: \"error\",\n        }));\n        onErrorRef.current?.(event);\n      };\n\n      wsRef.current.onclose = () => {\n        setConnectionState((prev) => ({\n          ...prev,\n          status: \"disconnected\",\n        }));\n        stopHeartbeat();\n        onCloseRef.current?.();\n\n        // Attempt to reconnect\n        if (connectionState.reconnectAttempt < maxReconnectAttempts) {\n          const attempt = connectionState.reconnectAttempt + 1;\n          const delay = getReconnectDelay(attempt);\n\n          setConnectionState((prev) => ({\n            ...prev,\n            reconnectAttempt: attempt,\n          }));\n\n          onReconnectRef.current?.(attempt);\n\n          reconnectTimeoutRef.current = setTimeout(() => {\n            connect();\n          }, delay);\n        }\n      };\n    } catch (error) {\n      console.error(\"WebSocket connection failed:\", error);\n      setConnectionState((prev) => ({\n        ...prev,\n        status: \"error\",\n      }));\n    }\n  }, [url, connectionState.reconnectAttempt, maxReconnectAttempts, startHeartbeat, stopHeartbeat]);\n\n  // Disconnect from WebSocket\n  const disconnect = useCallback(() => {\n    if (reconnectTimeoutRef.current) {\n      clearTimeout(reconnectTimeoutRef.current);\n    }\n    stopHeartbeat();\n\n    if (wsRef.current) {\n      wsRef.current.close();\n      wsRef.current = null;\n    }\n\n    setConnectionState({\n      status: \"disconnected\",\n      reconnectAttempt: 0,\n      latency: 0,\n    });\n  }, [stopHeartbeat]);\n\n  // Send message through WebSocket\n  const sendMessage = useCallback((message: Record<string, unknown>) => {\n    if (wsRef.current?.readyState === WebSocket.OPEN) {\n      wsRef.current.send(JSON.stringify(message));\n      return true;\n    }\n    return false;\n  }, []);\n\n  // Clear message queue\n  const clearMessages = useCallback(() => {\n    setMessages([]);\n  }, []);\n\n  // Auto-connect on mount with delay to allow API server to start\n  useEffect(() => {\n    // Small delay to allow API server to be ready (race condition fix)\n    const connectTimeout = setTimeout(() => {\n      connect();\n    }, 500);\n\n    return () => {\n      clearTimeout(connectTimeout);\n      disconnect();\n    };\n  }, []);\n\n  return {\n    connectionState,\n    messages,\n    sendMessage,\n    clearMessages,\n    connect,\n    disconnect,\n    isConnected: connectionState.status === \"connected\",\n    isReconnecting: connectionState.status === \"reconnecting\",\n  };\n};\n\n// Hook for optimistic updates with rollback\nexport const useOptimisticUpdate = <T>(\n  initialValue: T,\n  updateFn: (value: T) => Promise<T>,\n) => {\n  const [value, setValue] = useState(initialValue);\n  const [isUpdating, setIsUpdating] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n  const previousValueRef = useRef(initialValue);\n\n  const update = useCallback(\n    async (newValue: T | ((prev: T) => T)) => {\n      const nextValue =\n        typeof newValue === \"function\"\n          ? (newValue as (prev: T) => T)(value)\n          : newValue;\n\n      // Store previous value for rollback\n      previousValueRef.current = value;\n\n      // Optimistically update UI\n      setValue(nextValue);\n      setIsUpdating(true);\n      setError(null);\n\n      try {\n        // Perform actual update\n        const result = await updateFn(nextValue);\n        setValue(result); // Sync with server response\n        return result;\n      } catch (err) {\n        // Rollback on failure\n        setValue(previousValueRef.current);\n        setError(err as Error);\n        throw err;\n      } finally {\n        setIsUpdating(false);\n      }\n    },\n    [value, updateFn],\n  );\n\n  const reset = useCallback(() => {\n    setValue(initialValue);\n    setError(null);\n  }, [initialValue]);\n\n  return {\n    value,\n    update,\n    reset,\n    isUpdating,\n    error,\n    rollback: () => setValue(previousValueRef.current),\n  };\n};\n\n// Hook for adaptive polling\nexport const useAdaptivePolling = (\n  fetchFn: () => Promise<void>,\n  options: {\n    baseInterval?: number;\n    maxInterval?: number;\n    enabled?: boolean;\n    onError?: (error: Error) => void;\n  } = {},\n) => {\n  const {\n    baseInterval = 1000,\n    maxInterval = 30000,\n    enabled = true,\n    onError,\n  } = options;\n\n  const [isPolling, setIsPolling] = useState(false);\n  const [lastFetch, setLastFetch] = useState<Date | null>(null);\n  const [errorCount, setErrorCount] = useState(0);\n\n  const intervalRef = useRef<NodeJS.Timeout | undefined>(undefined);\n  const currentIntervalRef = useRef(baseInterval);\n\n  // Store fetchFn and onError in refs to avoid dependency issues\n  const fetchFnRef = useRef(fetchFn);\n  const onErrorRef = useRef(onError);\n\n  // Update refs when props change\n  useEffect(() => {\n    fetchFnRef.current = fetchFn;\n  }, [fetchFn]);\n\n  useEffect(() => {\n    onErrorRef.current = onError;\n  }, [onError]);\n\n  const adjustInterval = useCallback(\n    (success: boolean) => {\n      if (success) {\n        // Reset to base interval on success\n        currentIntervalRef.current = baseInterval;\n        setErrorCount(0);\n      } else {\n        // Exponential backoff on failure\n        currentIntervalRef.current = Math.min(\n          currentIntervalRef.current * 2,\n          maxInterval,\n        );\n        setErrorCount((prev) => prev + 1);\n      }\n    },\n    [baseInterval, maxInterval],\n  );\n\n  const poll = useCallback(async () => {\n    setIsPolling(true);\n    try {\n      await fetchFnRef.current();\n      setLastFetch(new Date());\n      adjustInterval(true);\n    } catch (error) {\n      console.error(\"Polling error:\", error);\n      adjustInterval(false);\n      onErrorRef.current?.(error as Error);\n    } finally {\n      setIsPolling(false);\n    }\n\n    // Schedule next poll\n    intervalRef.current = setTimeout(poll, currentIntervalRef.current);\n  }, [adjustInterval]);\n\n  // Start/stop polling based on enabled state\n  useEffect(() => {\n    if (enabled) {\n      poll();\n    }\n\n    return () => {\n      if (intervalRef.current) {\n        clearTimeout(intervalRef.current);\n      }\n    };\n  }, [enabled, poll]);\n\n  return {\n    isPolling,\n    lastFetch,\n    errorCount,\n    currentInterval: currentIntervalRef.current,\n    forceRefresh: poll,\n  };\n};\n"],"names":["useRealtimeConnection","config","url","reconnectDelay","maxReconnectAttempts","heartbeatInterval","onOpen","onClose","onError","onReconnect","connectionState","setConnectionState","useState","messages","setMessages","wsRef","useRef","reconnectTimeoutRef","heartbeatIntervalRef","pingTimestampRef","onOpenRef","onCloseRef","onErrorRef","onReconnectRef","useEffect","getReconnectDelay","attempt","startHeartbeat","useCallback","stopHeartbeat","connect","prev","event","data","latency","error","delay","disconnect","sendMessage","message","clearMessages","connectTimeout","useOptimisticUpdate","initialValue","updateFn","value","setValue","isUpdating","setIsUpdating","setError","previousValueRef","update","newValue","nextValue","result","err","reset","useAdaptivePolling","fetchFn","options","baseInterval","maxInterval","enabled","isPolling","setIsPolling","lastFetch","setLastFetch","errorCount","setErrorCount","intervalRef","currentIntervalRef","fetchFnRef","adjustInterval","success","poll"],"mappings":"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"}